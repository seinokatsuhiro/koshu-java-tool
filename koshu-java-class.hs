{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -Wall #-}

module Main (main) where

import qualified Data.ByteString.Lazy          as B
import qualified Data.Map                      as Map
import qualified Data.Set                      as Set
import qualified Data.Word                     as W
import qualified System.Environment            as E

import qualified JVM.Assembler                 as J
import qualified JVM.ClassFile                 as J
import qualified JVM.Converter                 as J
import qualified InstSize                      as J
import qualified InstTerms                     as J

import qualified Koshucode.Baala.Base          as K
import qualified Koshucode.Baala.Core          as K
import qualified Koshucode.Baala.Type.Vanilla  as K
import qualified Content                       as K

main :: IO ()
main = do
  args <- E.getArgs
  mapM_ dump args

dump :: String -> IO ()
dump path = do
  cls <- J.parseClassFile path
  dumpClassDirect cls

type ClassD        = J.Class       J.Direct
type ConstantD     = J.Constant    J.Direct
type FieldD        = J.Field       J.Direct
type MethodD       = J.Method      J.Direct
type AttributesD   = J.Attributes  J.Direct
type AccessFlagsD  = J.AccessFlags J.Direct


-- --------------------------------------------  Class

dumpClassDirect :: ClassD -> IO ()
dumpClassDirect c = K.putLines texts where
    texts     = concatGap [ dumpComment
                          , [ab, dumpClass c]
                          , o "**  Constant pool", pools
                          , o "**  Interface", ifs
                          , o "**  Field", fields
                          , o "**  Method", methods
                          , o "**  End"]
    o text    = [text]
    ab        = about [ term "this-class" $ pClass $ J.thisClass c ]
    pools     = dumpPool      `map`   (Map.assocs $ J.constsPool c)
    ifs       = dumpInterface `map`   J.interfaces c
    fields    = dumpField     `map`   J.classFields c
    methods   = dumpMeth  `concatMap` zip [1..] (J.classMethods c)
    dumpMeth  = dumpMethod $ J.thisClass c

dumpComment :: [String]
dumpComment = [ "** -*- koshu -*-"
              , "** "
              , "**  Java class file in Koshucode generated by 'koshu-java-class' command."
              , "** "
              ]

dumpClass :: ClassD -> String
dumpClass c =
    judge "CLASS" [ term "major"        $ K.pWord16  $ J.majorVersion c
                  , term "minor"        $ K.pWord16  $ J.minorVersion c
                  , term "super-class"  $ pClass   $ J.superClass c
                  , term "pool-size"    $ K.pWord16  $ J.constsPoolSize c
                  , term "accessor"     $ pAccSet  $ J.accessFlags c
                  , term "if-count"     $ K.pWord16  $ J.interfacesCount c
                  , term "field-count"  $ K.pWord16  $ J.classFieldsCount c
                  , term "method-count" $ K.pWord16  $ J.classMethodsCount c
                  , term "attr-count"   $ K.pWord16  $ J.classAttributesCount c
                  , term "attr"         $ pAttrSet $ J.classAttributes c ]

dumpInterface :: B.ByteString -> String
dumpInterface i = judge "INTERFACE" [ term "interface" $ pClass i ]


-- --------------------------------------------  Constant pool

dumpPool :: (W.Word16, ConstantD) -> String
dumpPool (i, J.CClass c) = judge "POOL-CLASS" xs where
    xs = [ term "index"     $ K.pWord16 i
         , term "class"     $ pClass c ]
dumpPool (i, J.CField c (J.NameType n t)) = judge "POOL-FIELD" xs where
    xs = [ term "index"     $ K.pWord16 i
         , term "class"     $ pClass c
         , term "field"     $ pBytes n
         , term "type"      $ pType t ]
dumpPool (i, J.CMethod c (J.NameType n m)) = judge "POOL-METHOD" xs where
    J.MethodSignature args ret = m
    xs = [ term "index"     $ K.pWord16 i
         , term "class"     $ pClass c
         , term "method"    $ pBytes n
         , term "args-type" $ pArgsType args
         , term "ret-type"  $ pRet ret ]
dumpPool (i, J.CIfaceMethod c (J.NameType n (J.MethodSignature args ret))) = judge "POOL-IF-METHOD" xs where
    xs = [ term "index"     $ K.pWord16 i
         , term "class"     $ pClass c
         , term "method"    $ pBytes n
         , term "args-type" $ pArgsType args
         , term "ret-type"  $ pRet ret ]
dumpPool (i, J.CString s) = judge "POOL-STRING" xs where
    xs = [ term "index"     $ K.pWord16 i
         , term "value"     $ pBytes s ]
dumpPool (i, J.CInteger n) = judge "POOL-INTEGER" xs where
    xs = [ term "index"     $ K.pWord16 i
         , term "value"     $ K.pWord32 n ]
dumpPool (i, J.CFloat _) = judge "POOL-FLOAT" xs where
    xs = [ term "index"     $ K.pWord16 i
         , term "value"     $ K.pText "unimplemented" ]
dumpPool (i, J.CLong _) = judge "POOL-LONG" xs where
    xs = [ term "index"     $ K.pWord16 i
         , term "value"     $ K.pText "unimplemented" ]
dumpPool (i, J.CDouble _) = judge "POOL-DOUBLE" xs where
    xs = [ term "index"     $ K.pWord16 i
         , term "value"     $ K.pText "unimplemented" ]
dumpPool (i, J.CNameType n t) = judge "POOL-NAME-TYPE" xs where
    xs = [ term "index"     $ K.pWord16 i
         , term "name"      $ pBytes n
         , term "type"      $ pBytes t]
dumpPool (i, J.CUTF8 s) = judge "POOL-UTF8" xs where
    xs = [ term "index"     $ K.pWord16 i
         , term "value"     $ pBytes s ]
dumpPool (i, J.CUnicode s) = judge "POOL-UNICODE" xs where
    xs = [ term "index"     $ K.pWord16 i
         , term "value"     $ pBytes s]


-- --------------------------------------------  Field

dumpField :: FieldD -> String
dumpField f =
    judge "FIELD"
         [ term "accessor"   $ pAccSet  $ J.fieldAccessFlags f
         , term "field"      $ pBytes   $ J.fieldName f
         , term "type"       $ pType    $ J.fieldSignature f
         , term "attr-count" $ K.pWord16  $ J.fieldAttributesCount f
         , term "attr"       $ pAttrSet $ J.fieldAttributes f ]


-- --------------------------------------------  Method

dumpMethod :: B.ByteString -> (Int, MethodD) -> [String]
dumpMethod clsName (n, m) = gap $ concatGap [[comm], ab : meth : code] where
    comm   = "**  Method #" ++ show n ++ ". " ++ J.toString name
    name   = J.methodName m
    ab     = about [ term "this-class"  $ pClass clsName
                   , term "method"      $ pBytes name ]
    meth   = let J.MethodSignature args ret = J.methodSignature m
             in judge "METHOD"
                    [ term "accessor"   $ pAccSet  $ J.methodAccessFlags m
                    , term "args-type"  $ pArgsType args
                    , term "ret-type"   $ pRet ret
                    , term "attr-count" $ K.pWord16  $ J.methodAttributesCount m
                    , term "attr"       $ pAttrSet $ J.methodAttributes m ]
    code   = case J.attrByName m "Code" of
               Nothing -> ["** no code"]
               Just bytecode -> dumpCode $ J.decodeMethod bytecode

dumpCode :: J.Code -> [String]
dumpCode c = concatGap [[code], insts, details, excs] where
      code     = judge "CODE" [ term "stack-size"      $ K.pWord16 $ J.codeStackSize c
                              , term "max-locals"      $ K.pWord16 $ J.codeMaxLocals c
                              , term "length"          $ K.pWord32 $ J.codeLength c
                              , term "exception-count" $ K.pWord16 $ J.codeExceptionsN c
                              , term "attr-count"      $ K.pWord16 $ J.codeAttrsN c
                              , term "attr"            $ pAttrList $ J.codeAttributes c ]
      inst     = countPC $ J.codeInstructions c
      insts    = map dumpInst inst
      details  = concatMap dumpInstDetail inst
      excs     = map dumpException $ J.codeExceptions c

dumpException :: J.CodeException -> String
dumpException (J.CodeException start end handler catch) = judge "EXCEPTION" xs where
    xs = [ term "start"            $ K.pWord16 start
         , term "end"              $ K.pWord16 end
         , term "handler"          $ K.pWord16 handler
         , term "catch-type-index" $ K.pWord16 catch ]


countPC :: [J.Instruction] -> [(J.PC, J.Instruction)]
countPC = loop 0 where
    loop _ [] = []
    loop p (i:is) = (p, i) : loop (p + J.instSize i) is


-- --------------------------------------------  Instruction

dumpInst :: (J.PC, J.Instruction) -> String
dumpInst (p, i) = judge "INST" $ pc : J.instTerms i where
    pc = term "pc" $ K.pDecFromInt p

dumpInstDetail :: (J.PC, J.Instruction) -> [String]
dumpInstDetail (n, J.TABLESWITCH _ _ from _ sw)  = dumpSwitch n (zip [from ..] sw)
dumpInstDetail (n, J.LOOKUPSWITCH _ _ _ sw)      = dumpSwitch n sw

dumpInstDetail (n, J.GETSTATIC i)          = dumpInstField  n i "getstatic"
dumpInstDetail (n, J.PUTSTATIC i)          = dumpInstField  n i "putstatic"
dumpInstDetail (n, J.GETFIELD i)           = dumpInstField  n i "getfield"
dumpInstDetail (n, J.PUTFIELD i)           = dumpInstField  n i "putfield"

dumpInstDetail (n, J.INVOKEVIRTUAL i)      = dumpInstMethod n i "invokevirtual"
dumpInstDetail (n, J.INVOKESPECIAL i)      = dumpInstMethod n i "invokespecial"
dumpInstDetail (n, J.INVOKESTATIC i)       = dumpInstMethod n i "invokestatic"
dumpInstDetail (n, J.INVOKEINTERFACE i _)  = dumpInstMethod n i "invokeinterface"

dumpInstDetail (n, J.NEW i)                = dumpInstMethod n i "new"
dumpInstDetail (n, J.ANEWARRAY i)          = dumpInstClass  n i "anewarray"
dumpInstDetail (n, J.CHECKCAST i)          = dumpInstClass  n i "checkcast"
dumpInstDetail (n, J.INSTANCEOF i)         = dumpInstClass  n i "instanceof"

dumpInstDetail (n, J.WIDE _ i)             = dumpInstWide n i
dumpInstDetail _ = []

dumpInstClass :: J.PC -> W.Word16 -> String -> [String]
dumpInstClass n i op = [judge "INST-CLASS" xs] where
    xs = [ term "pc"    $ K.pPC n
         , term "op"    $ K.pText op
         , term "index" $ K.pWord16 i ]

dumpInstField :: J.PC -> W.Word16 -> String -> [String]
dumpInstField n i op = [judge "INST-FIELD" xs] where
    xs = [ term "pc"    $ K.pPC n
         , term "op"    $ K.pText op
         , term "index" $ K.pWord16 i ]

dumpInstMethod :: J.PC -> W.Word16 -> String -> [String]
dumpInstMethod n i op = [judge "INST-METHOD" xs] where
    xs = [ term "pc"    $ K.pPC n
         , term "op"    $ K.pText op
         , term "index" $ K.pWord16 i ]

dumpSwitch :: J.PC -> [(W.Word32, W.Word32)] -> [String]
dumpSwitch n switch = map j switch where
    j (w, g) = judge "INST-SWITCH"
                     [ term "pc"    $ K.pPC n
                     , term "when"  $ K.pWord32 w
                     , term "jump"  $ K.pWord32 g ]

dumpInstWide :: J.PC -> J.Instruction -> [String]
dumpInstWide n i = [judge "INST-WIDE" $ pc : J.instTerms i] where
    pc = term "pc" $ K.pPC n


-- --------------------------------------------  Putter

pAccSet :: AccessFlagsD -> K.VContent
pAccSet a = K.pSet $ K.pText `map` accessFlagsText a

pAttrList :: J.Attributes J.File -> K.VContent
pAttrList a = K.pSet $ (K.pWord16 . J.attributeName) `map` J.attributesList a

pAttrSet :: AttributesD -> K.VContent
pAttrSet a = K.pSet $ (pBytes . fst) `map` J.arlist a

pClass :: B.ByteString -> K.VContent
pClass c = K.pText $ map dot $ J.toString c where
    dot '/' = '.'
    dot x   = x

pClassText :: String -> K.VContent
pClassText s = K.pText $ map dot s where
    dot '/' = '.'
    dot x   = x

pBytes :: B.ByteString -> K.VContent
pBytes = K.pText . J.toString

pArgsType :: [J.FieldType] -> K.VContent
pArgsType args = K.pList $ pType `map` args


-- --------------------------------------------  Utility

accessFlagsText :: AccessFlagsD -> [String]
accessFlagsText = map accessFlagText . Set.elems

accessFlagText :: J.AccessFlag -> String
accessFlagText J.ACC_PUBLIC        = "public"
accessFlagText J.ACC_PRIVATE       = "private"
accessFlagText J.ACC_PROTECTED     = "protected"
accessFlagText J.ACC_STATIC        = "static"
accessFlagText J.ACC_FINAL         = "final"
accessFlagText J.ACC_SYNCHRONIZED  = "synchronized"
accessFlagText J.ACC_VOLATILE      = "volatile"
accessFlagText J.ACC_TRANSIENT     = "transient"
accessFlagText J.ACC_NATIVE        = "native"
accessFlagText J.ACC_INTERFACE     = "interface"
accessFlagText J.ACC_ABSTRACT      = "abstract"

pType :: J.FieldType -> K.VContent
pType J.SignedByte          = K.pText "byte"
pType J.CharByte            = K.pText "char"
pType J.DoubleType          = K.pText "double"
pType J.FloatType           = K.pText "float"
pType J.IntType             = K.pText "int"
pType J.LongInt             = K.pText "long"
pType J.ShortInt            = K.pText "short"
pType J.BoolType            = K.pText "bool"
pType (J.ObjectType s)      = pClassText s
pType (J.Array _ t)         = K.pList [pType t]

pRet :: J.ReturnSignature -> K.VContent
pRet (J.Returns t)  = pType t
pRet J.ReturnsVoid  = K.pText "void"

gap :: K.Map [String]
gap xs@("" : _) = xs
gap xs          = "" : xs

concatGap :: [[String]] -> [String]
concatGap [] = []
concatGap (x:xs) = x ++ concatMap gap xs

about :: (K.Write c) => [K.Named c] -> String
about xs = "about " ++ xs' where
    xs' = show $ K.writeTerms (K.write K.shortEmpty) xs

judge :: String -> [(String, K.VContent)] -> String
judge pat = K.judgeShow K.shortEmpty . K.JudgeAffirm pat

term :: String -> c -> (String, c)
term n c = (n, c)
